#! /usr/bin/python

# To change this license header, choose License Headers in Project Properties.
# To change this template file, choose Tools | Templates
# and open the template in the editor.

__author__ = "Tomas Oberhuber"
__date__ = "$May 6, 2015 8:40:59 PM$"

import TNL


def generateProblem( problemName, problemBaseName ):

def generateOperatorGridSpecializationHeader( file, operatorName, dimensions ):
    file.write( "template< typename MeshReal,\n" )
    file.write( "          typename Device,\n" )
    file.write( "          typename MeshIndex,\n" )
    file.write( "          typename Real,\n" )
    file.write( "          typename Index >\n" )
    file.write( "class " + operatorName + "< tnlGrid< " + dimensions + ",MeshReal, Device, MeshIndex >, Real, Index >\n" )
    file.write( "{\n" )
    file.write( "   public:\n" )
    file.write( "      typedef tnlGrid< " + dimensions + ", MeshReal, Device, MeshIndex > MeshType;\n" )
    file.write( "      typedef typename MeshType::CoordinatesType CoordinatesType;\n" )
    file.write( "      typedef Real RealType;\n" )
    file.write( "      typedef Device DeviceType;\n" )
    file.write( "      typedef Index IndexType;\n" )
    file.write( "      typedef tnlMeshFunction< MeshType > MeshFunctionType;\n" )
    file.write( "      enum { Dimensions = MeshType::getMeshDimensions() };\n" )
    file.write( "\n" )
    file.write( "      static tnlString getType();\n" )
    file.write( "\n" )
    file.write( "      template< typename MeshFunction, typename MeshEntity >\n" )
    file.write( "      __cuda_callable__\n" )
    file.write( "      Real operator()( const MeshFunction& u,\n" )
    file.write( "                       const MeshEntity& entity,\n" )
    file.write( "                       const RealType& time = 0.0 ) const;\n" )
    file.write( "\n" )
    file.write( "      __cuda_callable__\n" )
    file.write( "      template< typename MeshEntity >\n" )    
    file.write( "      Index getLinearSystemRowLength( const MeshType& mesh,\n" )
    file.write( "                                      const IndexType& index,\n" )
    file.write( "                                      const MeshEntity& entity ) const;\n" )
    file.write( "\n" )
    file.write( "      template< typename MeshEntity, typename Vector, typename MatrixRow >\n" )
    file.write( "      __cuda_callable__\n" )
    file.write( "      void updateLinearSystem( const RealType& time,\n" )
    file.write( "                               const RealType& tau,\n" )
    file.write( "                               const MeshType& mesh,\n" )
    file.write( "                               const IndexType& index,\n" )
    file.write( "                               const MeshEntity& entity,\n" )
    file.write( "                               const MeshFunctionType& u,\n" )
    file.write( "                               Vector& b,\n" )
    file.write( "                               MatrixRow& matrixRow ) const;\n" )
    file.write( "};\n" )
    file.write( "\n" )    
    
def generateOperatorGridSpecializationImplementation( file, operatorName, dimensions ):
    file.write( "template< typename MeshReal,\n" )
    file.write( "          typename Device,\n" )
    file.write( "          typename MeshIndex,\n" )
    file.write( "          typename Real,\n" )
    file.write( "          typename Index >\n" )
    file.write( "tnlString\n" )
    file.write( operatorName + "< tnlGrid< " + dimensions + ", MeshReal, Device, MeshIndex >, Real, Index >::\n" )
    file.write( "getType()\n" )
    file.write( "{\n" )
    file.write( "   return tnlString( \"" + operatorName + "< \" ) +\n" )
    file.write( "          MeshType::getType() + \", \" +\n" )
    file.write( "          ::getType< Real >() + \", \" +\n" )
    file.write( "          ::getType< Index >() + \" >\";\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename MeshReal,\n" )
    file.write( "          typename Device,\n" )
    file.write( "          typename MeshIndex,\n" )
    file.write( "          typename Real,\n" )
    file.write( "          typename Index >\n" )    
    file.write( "template< typename MeshFunction, typename MeshEntity >\n" )
    file.write( "__cuda_callable__\n" )
    file.write( "Real\n" )
    file.write( operatorName + "< tnlGrid< " + dimensions + ", MeshReal, Device, MeshIndex >, Real, Index >::\n" )
    file.write( "operator()( const MeshFunction& u,\n" )
    file.write( "            const MeshEntity& entity,\n" )
    file.write( "            const Real& time ) const\n" )
    file.write( "{\n" )
    file.write( "   /****\n" )
    file.write( "    * Implement your explicit form of the differential operator here.\n" )
    file.write( "    * The following example is the Laplace operator approximated \n" )
    file.write( "    * by the Finite difference method.\n" )
    file.write( "    */\n" )  
    file.write( '    static_assert( MeshEntity::entityDimensions == ' + dimensions + ', "Wrong mesh entity dimensions." ); \n' )
    file.write( '    static_assert( MeshFunction::getEntitiesDimensions() == ' + dimensions + ', "Wrong preimage function" ); \n' )
    file.write( "    const typename MeshEntity::template NeighbourEntities< " + dimensions + " >& neighbourEntities = entity.getNeighbourEntities(); \n" )
    file.write( "\n" )
    if dimensions == "1":
        file.write( "   const RealType& hxSquareInverse = entity.getMesh().template getSpaceStepsProducts< -2 >(); \n" )
        file.write( "   const IndexType& center = entity.getIndex(); \n" )
        file.write( "   const IndexType& east = neighbourEntities.template getEntityIndex< 1 >(); \n" )
        file.write( "   const IndexType& west = neighbourEntities.template getEntityIndex< -1 >(); \n" )
        file.write( "   return ( u[ west ] - 2.0 * u[ center ]  + u[ east ] ) * hxSquareInverse;\n" )
    if dimensions == "2":
        file.write( "   const RealType& hxSquareInverse = entity.getMesh().template getSpaceStepsProducts< -2, 0 >(); \n" )
        file.write( "   const RealType& hySquareInverse = entity.getMesh().template getSpaceStepsProducts< 0, -2 >(); \n" )
        file.write( "   const IndexType& center = entity.getIndex(); \n" )
        file.write( "   const IndexType& east  = neighbourEntities.template getEntityIndex<  1,  0 >(); \n" )
        file.write( "   const IndexType& west  = neighbourEntities.template getEntityIndex< -1,  0 >(); \n" )
        file.write( "   const IndexType& north = neighbourEntities.template getEntityIndex<  0,  1 >(); \n" )
        file.write( "   const IndexType& south = neighbourEntities.template getEntityIndex<  0, -1 >(); \n" )        
        file.write( "   return ( u[ west ] - 2.0 * u[ center ] + u[ east ]  ) * hxSquareInverse +\n" )
        file.write( "          ( u[ south ] - 2.0 * u[ center ] + u[ north ] ) * hySquareInverse;\n" )
    if dimensions == "3":
        file.write( "   const RealType& hxSquareInverse = entity.getMesh().template getSpaceStepsProducts< -2,  0,  0 >(); \n" )
        file.write( "   const RealType& hySquareInverse = entity.getMesh().template getSpaceStepsProducts<  0, -2,  0 >(); \n" )
        file.write( "   const RealType& hzSquareInverse = entity.getMesh().template getSpaceStepsProducts<  0,  0, -2 >(); \n" )
        file.write( "   const IndexType& center = entity.getIndex(); \n" )
        file.write( "   const IndexType& east  = neighbourEntities.template getEntityIndex<  1,  0,  0 >(); \n" )
        file.write( "   const IndexType& west  = neighbourEntities.template getEntityIndex< -1,  0,  0 >(); \n" )
        file.write( "   const IndexType& north = neighbourEntities.template getEntityIndex<  0,  1,  0 >(); \n" )
        file.write( "   const IndexType& south = neighbourEntities.template getEntityIndex<  0, -1,  0 >(); \n" )        
        file.write( "   const IndexType& up    = neighbourEntities.template getEntityIndex<  0,  0,  1 >(); \n" )
        file.write( "   const IndexType& down  = neighbourEntities.template getEntityIndex<  0,  0, -1 >(); \n" )        
        file.write( "   return ( u[ west ] - 2.0 * u[ center ] + u[ east ]  ) * hxSquareInverse +\n" )
        file.write( "          ( u[ south ] - 2.0 * u[ center ] + u[ north ] ) * hySquareInverse +\n" )
        file.write( "          ( u[ up ] - 2.0 * u[ center ] + u[ down ] ) * hzSquareInverse;\n" )                
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename MeshReal,\n" )
    file.write( "          typename Device,\n" )
    file.write( "          typename MeshIndex,\n" )
    file.write( "          typename Real,\n" )
    file.write( "          typename Index >\n" )        
    file.write( "template< typename MeshEntity >\n" )
    file.write( "__cuda_callable__\n" )
    file.write( "Index\n" )
    file.write( operatorName + "< tnlGrid< " + dimensions + ", MeshReal, Device, MeshIndex >, Real, Index >::\n" )
    file.write( "getLinearSystemRowLength( const MeshType& mesh,\n" )
    file.write( "                          const IndexType& index,\n" )
    file.write( "                          const MeshEntity& entity ) const\n" )
    file.write( "{\n" )
    file.write( "   /****\n" )
    file.write( "    * Return a number of non-zero elements in a line (associated with given grid element) of\n" )
    file.write( "    * the linear system.\n" )
    file.write( "    * The following example is the Laplace operator approximated \n" )
    file.write( "    * by the Finite difference method.\n" )
    file.write( "    */\n" )
    file.write( "\n" )
    file.write( "   return 2*Dimensions + 1;\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename MeshReal,\n" )
    file.write( "          typename Device,\n" )
    file.write( "          typename MeshIndex,\n" )
    file.write( "          typename Real,\n" )
    file.write( "          typename Index >\n" )
    file.write( "   template< typename MeshEntity, typename Vector, typename MatrixRow >\n" )       
    file.write( "__cuda_callable__\n" )        
    file.write( "void\n" )
    file.write( operatorName + "< tnlGrid< " + dimensions + ", MeshReal, Device, MeshIndex >, Real, Index >::\n" )
    file.write( "updateLinearSystem( const RealType& time,\n" )
    file.write( "                    const RealType& tau,\n" )
    file.write( "                    const MeshType& mesh,\n" )
    file.write( "                    const IndexType& index,\n" )
    file.write( "                    const MeshEntity& entity,\n" )
    file.write( "                    const MeshFunctionType& u,\n" )
    file.write( "                    Vector& b,\n" )
    file.write( "                    MatrixRow& matrixRow ) const\n" )
    file.write( "{\n" )
    file.write( "   /****\n" )
    file.write( "    * Setup the non-zero elements of the linear system here.\n" )
    file.write( "    * The following example is the Laplace operator appriximated \n" )
    file.write( "    * by the Finite difference method.\n" )
    file.write( "    */\n" )    
    file.write( "\n" )
    file.write( "    const typename MeshEntity::template NeighbourEntities< " + dimensions + " >& neighbourEntities = entity.getNeighbourEntities(); \n" )
    if dimensions == "1":
       file.write( "   const RealType& lambdaX = tau * entity.getMesh().template getSpaceStepsProducts< -2 >(); \n" )
       file.write( "   const IndexType& center = entity.getIndex(); \n" )
       file.write( "   const IndexType& east = neighbourEntities.template getEntityIndex< 1 >(); \n" )
       file.write( "   const IndexType& west = neighbourEntities.template getEntityIndex< -1 >(); \n" )
       file.write( "   matrixRow.setElement( 0, west,   - lambdaX );\n" )
       file.write( "   matrixRow.setElement( 1, center, 2.0 * lambdaX );\n" )
       file.write( "   matrixRow.setElement( 2, east,   - lambdaX );\n" )
    if dimensions == "2":
        file.write( "   const RealType& lambdaX = tau * entity.getMesh().template getSpaceStepsProducts< -2, 0 >(); \n" )
        file.write( "   const RealType& lambdaY = tau * entity.getMesh().template getSpaceStepsProducts< 0, -2 >(); \n" )
        file.write( "   const IndexType& center = entity.getIndex(); \n" )
        file.write( "   const IndexType& east  = neighbourEntities.template getEntityIndex<  1,  0 >(); \n" )
        file.write( "   const IndexType& west  = neighbourEntities.template getEntityIndex< -1,  0 >(); \n" )
        file.write( "   const IndexType& north = neighbourEntities.template getEntityIndex<  0,  1 >(); \n" )
        file.write( "   const IndexType& south = neighbourEntities.template getEntityIndex<  0, -1 >(); \n" )        
        file.write( "   matrixRow.setElement( 0, south,  -lambdaY );\n" )
        file.write( "   matrixRow.setElement( 1, west,   -lambdaX );\n" )
        file.write( "   matrixRow.setElement( 2, center, 2.0 * ( lambdaX + lambdaY ) );\n" )
        file.write( "   matrixRow.setElement( 3, east,   -lambdaX );\n" )
        file.write( "   matrixRow.setElement( 4, north,  -lambdaY );\n" )
    if dimensions == "3":
        file.write( "   const RealType& lambdaX = tau * entity.getMesh().template getSpaceStepsProducts< -2,  0,  0 >(); \n" )
        file.write( "   const RealType& lambdaY = tau * entity.getMesh().template getSpaceStepsProducts<  0, -2,  0 >(); \n" )
        file.write( "   const RealType& lambdaZ = tau * entity.getMesh().template getSpaceStepsProducts<  0,  0, -2 >(); \n" )
        file.write( "   const IndexType& center = entity.getIndex(); \n" )
        file.write( "   const IndexType& east  = neighbourEntities.template getEntityIndex<  1,  0,  0 >(); \n" )
        file.write( "   const IndexType& west  = neighbourEntities.template getEntityIndex< -1,  0,  0 >(); \n" )
        file.write( "   const IndexType& north = neighbourEntities.template getEntityIndex<  0,  1,  0 >(); \n" )
        file.write( "   const IndexType& south = neighbourEntities.template getEntityIndex<  0, -1,  0 >(); \n" )        
        file.write( "   const IndexType& up    = neighbourEntities.template getEntityIndex<  0,  0,  1 >(); \n" )
        file.write( "   const IndexType& down  = neighbourEntities.template getEntityIndex<  0,  0, -1 >(); \n" )                
        file.write( "   matrixRow.setElement( 0, down,   -lambdaZ );\n" )
        file.write( "   matrixRow.setElement( 1, south,  -lambdaY );\n" )
        file.write( "   matrixRow.setElement( 2, west,   -lambdaX );\n" )
        file.write( "   matrixRow.setElement( 3, center, 2.0 * ( lambdaX + lambdaY + lambdaZ ) );\n" )
        file.write( "   matrixRow.setElement( 4, east,   -lambdaX );\n" )
        file.write( "   matrixRow.setElement( 5, north,  -lambdaY );\n" )
        file.write( "   matrixRow.setElement( 6, up,     -lambdaZ );\n" )
    file.write( "}\n" )
    file.write( "\n" )
    
def generateOperator( operatorName):
    file = open( operatorName + ".h", "w" )    
    file.write( "#ifndef " + operatorName + "_H\n" )
    file.write( "#define " + operatorName + "_H\n" )
    file.write( "\n" )
    file.write( "#include <core/vectors/tnlVector.h>\n" )
    file.write( "#include <mesh/tnlGrid.h>\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename Real = typename Mesh::RealType,\n" )
    file.write( "          typename Index = typename Mesh::IndexType >\n" )
    file.write( "class " + operatorName + "\n" )
    file.write( "{\n" )
    file.write( "};\n" )
    file.write( "\n" )
    generateOperatorGridSpecializationHeader( file, operatorName, "1" )
    generateOperatorGridSpecializationHeader( file, operatorName, "2" )
    generateOperatorGridSpecializationHeader( file, operatorName, "3" )
    file.write( "\n" )
    file.write( "#include \""+ operatorName + "_impl.h\"\n" )
    file.write( "\n" )
    file.write( "#endif	/* " + operatorName + "_H */\n" )
    file.close()
    file = open( operatorName + "_impl.h", "w" )    
    file.write( "#ifndef " + operatorName + "_IMPL_H\n" )
    file.write( "#define " + operatorName + "_IMPL_H\n" )
    file.write( "\n" )
    file.write( "/****\n" )
    file.write( " * 1D problem\n" )
    file.write( " */\n" )
    generateOperatorGridSpecializationImplementation( file, operatorName, "1" )
    file.write( "/****\n" )
    file.write( " * 2D problem\n" )
    file.write( " */\n" )
    generateOperatorGridSpecializationImplementation( file, operatorName, "2" )
    file.write( "/****\n" )
    file.write( " * 3D problem\n" )
    file.write( " */\n" )    
    generateOperatorGridSpecializationImplementation( file, operatorName, "3" )
    file.write( "#endif	/* " + operatorName + "IMPL_H */\n" )
    file.write( "\n" )
    file.close()
    
def generateRhs( problemBaseName ):
    file = open( problemBaseName + "Rhs.h", "w" )
    file.write( "#ifndef " + problemBaseName + "RHS_H_\n" )
    file.write( "#define " + problemBaseName + "RHS_H_\n" )
    file.write( "#include<functions/tnlDomain.h>")
    file.write( "\n" )
    file.write( "template< typename Mesh, typename Real >" )
    file.write( "class " + problemBaseName + "Rhs\n" )
    file.write( "  : public tnlDomain< Mesh::meshDimensions, MeshDomain > \n " )
    file.write( "{\n" )
    file.write( "   public:\n" )
    file.write( "\n" )
    file.write( "      typedef Mesh MeshType;\n" )
    file.write( "      typedef Real RealType;\n" )
    file.write( "\n" )
    file.write( "      bool setup( const tnlParameterContainer& parameters,\n" )
    file.write( "                  const tnlString& prefix = \"\" )\n" )
    file.write( "      {\n" )
    file.write( "         return true;\n" )
    file.write( "      }\n" )
    file.write( "\n" )
    file.write( "      template< typename MeshEntity >\n" )   
    file.write( "      __cuda_callable__\n" )
    file.write( "      Real operator()( const MeshEntity& entity,\n" )
    file.write( "                       const Real& time = 0.0 ) const\n" )    
    file.write( "      {\n" )    
    file.write( "         typedef typename MeshEntity::MeshType::VertexType VertexType;\n" )
    file.write( "         VertexType v = entity.getCenter();\n" )        
    file.write( "         return 0.0;\n" )    
    file.write( "      };\n" )    
    file.write( "};\n" )    
    file.write( "\n" )    
    file.write( "#endif /* " + problemBaseName + "RHS_H_ */\n" )    
    file.close()

def generateBuildConfigTags( problemBaseName ):
    file = open( problemBaseName + "BuildConfigTag.h", "w" )
    file.write( "#ifndef " + problemBaseName + "BUILDCONFIGTAG_H_\n" )
    file.write( "#define " + problemBaseName + "BUILDCONFIGTAG_H_\n" )
    file.write( "\n" )
    file.write( "#include <solvers/tnlBuildConfigTags.h>\n" )
    file.write( "\n" )
    file.write( "class " + problemBaseName + "BuildConfigTag{};\n" )
    file.write( "\n" )
    file.write( "/****\n" )
    file.write( " * Turn off support for float and long double.\n" )
    file.write( " */\n" )
    file.write( "template<> struct tnlConfigTagReal< " + problemBaseName + "BuildConfigTag, float > { enum { enabled = false }; };\n" )
    file.write( "template<> struct tnlConfigTagReal< " + problemBaseName + "BuildConfigTag, long double > { enum { enabled = false }; };\n" )
    file.write( "\n" )
    file.write( "/****\n" )
    file.write( " * Turn off support for short int and long int indexing.\n" )
    file.write( " */\n" )
    file.write( "template<> struct tnlConfigTagIndex< " + problemBaseName + "BuildConfigTag, short int >{ enum { enabled = false }; };\n" )
    file.write( "template<> struct tnlConfigTagIndex< " + problemBaseName + "BuildConfigTag, long int >{ enum { enabled = false }; };\n" )
    file.write( "\n" )    
    file.write( "/****\n" )
    file.write( " * How many dimensions may have the problem to be solved...\n" )
    file.write( " */\n" )    
    file.write( "template< int Dimensions > struct tnlConfigTagDimensions< " + problemName + "BuildConfigTag, Dimensions >{ enum { enabled = ( Dimensions == 1 ) }; };\n" )
    file.write( "\n" )
    file.write( "/****\n" )
    file.write( " * Use of tnlGrid is enabled for allowed dimensions and Real, Device and Index types.\n" )
    file.write( " */\n" )
    file.write( "template< int Dimensions, typename Real, typename Device, typename Index >\n" )
    file.write( "   struct tnlConfigTagMesh< " + problemBaseName + "BuildConfigTag, tnlGrid< Dimensions, Real, Device, Index > >\n" )
    file.write( "      { enum { enabled = tnlConfigTagDimensions< " + problemBaseName + "BuildConfigTag, Dimensions >::enabled  &&\n" )
    file.write( "                         tnlConfigTagReal< " + problemBaseName + "BuildConfigTag, Real >::enabled &&\n" )
    file.write( "                         tnlConfigTagDevice< " + problemBaseName + "BuildConfigTag, Device >::enabled &&\n" )
    file.write( "                         tnlConfigTagIndex< " + problemBaseName + "BuildConfigTag, Index >::enabled }; };\n" )
    file.write( "\n" )
    file.write( "/****\n" )
    file.write( " * Please, chose your preferred time discretisation  here.\n" )
    file.write( " */\n" )
    file.write( "template<> struct tnlConfigTagTimeDiscretisation< " + problemBaseName + "BuildConfigTag, tnlExplicitTimeDiscretisationTag >{ enum { enabled = true }; };\n" )
    file.write( "template<> struct tnlConfigTagTimeDiscretisation< " + problemBaseName + "BuildConfigTag, tnlSemiImplicitTimeDiscretisationTag >{ enum { enabled = true }; };\n" )
    file.write( "template<> struct tnlConfigTagTimeDiscretisation< " + problemBaseName + "BuildConfigTag, tnlImplicitTimeDiscretisationTag >{ enum { enabled = false }; };\n" )
    file.write( "\n" )
    file.write( "/****\n" )
    file.write( " * Only the Runge-Kutta-Merson solver is enabled by default.\n" )
    file.write( " */\n" )
    file.write( "template<> struct tnlConfigTagExplicitSolver< " + problemBaseName + "BuildConfigTag, tnlExplicitEulerSolverTag >{ enum { enabled = false }; };\n" )
    file.write( "\n" )        
    file.write( "#endif /* " + problemBaseName + "BUILDCONFIGTAG_H_ */\n" )        
    file.close()
    

def generateRunScript( problemBaseName ):
    file = open( "run-" + problemBaseName, "w" )
    file.write( "#!/usr/bin/env bash\n" ) 
    file.write( "\n" ) 
    file.write( "tnl-grid-setup --dimensions 2 \\\n" ) 
    file.write( "               --origin-x 0.0 \\\n" ) 
    file.write( "               --origin-y 0.0 \\\n" ) 
    file.write( "               --proportions-x 1.0 \\\n" ) 
    file.write( "               --proportions-y 1.0 \\\n" ) 
    file.write( "               --size-x 100 \\\n" ) 
    file.write( "               --size-y 100\n" ) 
    file.write( "\n" ) 
    file.write( "tnl-init --test-function sin-wave \\\n" ) 
    file.write( "         --output-file init.tnl\n" ) 
    file.write( "./" + problemBaseName + " --time-discretisation explicit \\\n" ) 
    file.write( "              --boundary-conditions-constant 0 \\\n" )
    file.write( "              --discrete-solver merson \\\n" ) 
    file.write( "              --snapshot-period 0.01 \\\n" ) 
    file.write( "              --final-time 1.0\n" ) 
    file.write( "\n" ) 
    file.write( "tnl-view --mesh mesh.tnl --input-files *tnl     \n" ) 
    file.close()
    
print( "TNL Quickstart -- solver generator")
print( "----------------------------------")

definitions = {}

definitions['problemName'] = input( "Problam name:" )
definitions['problemBaseName'] = input( "Problem class base name (base name acceptable in C++ code):" )
definitions['operatorName'] = input( "Operator name:")

with open( Config.tnl_install_prefix+"/Makefile.py.in", 'r') as ftemp:
    templateString = ftemp.read()
with open( "Makefile", 'w') as file:
    file.write( templateString.format(**definitions ) )


generateMakefile( problemBaseName )
generateMain( problemName, problemBaseName, operatorName )
generateProblem( problemName, problemBaseName )
generateOperator( operatorName )
generateRhs( problemBaseName )
generateBuildConfigTags( problemBaseName )
generateRunScript( problemBaseName )