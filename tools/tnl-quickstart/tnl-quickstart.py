#! /usr/bin/python

# To change this license header, choose License Headers in Project Properties.
# To change this template file, choose Tools | Templates
# and open the template in the editor.

__author__ = "Tomas Oberhuber"
__date__ = "$May 6, 2015 8:40:59 PM$"


def generateMakefile( problemBaseName ):
    file = open( "Makefile", "w" )
    file.write( "# Uncomment the following line to enable CUDA\n" )
    file.write( "#WITH_CUDA = yes\n" )
    file.write( "\n" ) 
    file.write( "TARGET = " + problemBaseName + "\n")
    file.write( "INSTALL_DIR = ${HOME}/local\n" )
    file.write( "\n" )
    file.write( "LDFLAGS = $(shell tnl-link )\n" )
    file.write( "\n" )
    file.write( "ifdef WITH_CUDA\n" )
    file.write( "   CXX = nvcc\n" )     
    file.write( "   CXX_FLAGS = $(shell tnl-compile --cuda)\n" )    
    file.write( "else\n" )                                  
    file.write( "   CXX = g++\n" ) 
    file.write( "   CXX_FLAGS = $(shell tnl-compile)\n" )    
    file.write( "endif\n" )                              
    file.write( "\n" )
    file.write( "SOURCES = " + problemBaseName + ".cpp\n" )
    file.write( "HEADERS = " + problemBaseName + ".h\n" )
    file.write( "OBJECTS = " + problemBaseName + ".o\n" ) 
    file.write( "DIST = $(SOURCES) $(CUDA_SOURCES) $(HEADERS) Makefile\n" ) 
    file.write( "\n" ) 
    file.write( "ifdef WITH_CUDA\n" )
    file.write( "   OBJECTS = " + problemBaseName + "-cuda.o\n" )     
    file.write( "endif\n" )     
    file.write( "\n" )     
    file.write( "all: $(TARGET)\n" ) 
    file.write( "\n" ) 
    file.write( "clean:\n" ) 
    file.write( "\t rm -f *.o" ) 
    file.write( "\n" ) 
    file.write( "dist: $(DIST)" ) 
    file.write( "\t tar zcvf $(TARGET).tgz $(DIST)\n" ) 
    file.write( "\n" ) 
    file.write( "$(TARGET): $(OBJECTS)\n" ) 
    file.write( "\t$(CXX) -o $@ $< $(LDFLAGS)\n" ) 
    file.write( "\n" ) 
    file.write( "%.o: %.cpp\n" ) 
    file.write( "\t $(CXX) $(CPPFLAGS) $(CXX_FLAGS) -c -o $@ $<" ) 
    file.write( "\n" ) 
    file.write( "%.o: %.cu\n" ) 
    file.write( "\t $(CXX) $(CPPFLAGS) $(CXX_FLAGS) -c -o $@ $<" )     
    file.close()

def generateMain( problemName, problemBaseName, operatorName ):
    file = open( problemBaseName + ".h", "w" )
    file.write( "#include <tnlConfig.h>\n" )
    file.write( "#include <solvers/tnlSolver.h>\n" )
    file.write( "#include <solvers/tnlConfigTags.h>\n" )
    file.write( "#include <solvers/tnlFastBuildConfig.h>\n" )    
    file.write( "#include <operators/tnlAnalyticDirichletBoundaryConditions.h>\n" )
    file.write( "#include <operators/tnlDirichletBoundaryConditions.h>\n" )
    file.write( "#include <operators/tnlAnalyticNeumannBoundaryConditions.h>\n" )
    file.write( "#include <operators/tnlNeumannBoundaryConditions.h>\n" )
    file.write( "#include <functors/tnlConstantFunction.h>\n" )
    file.write( "#include \"" + problemBaseName + "Problem.h\"\n" )
    file.write( "#include \"" + operatorName + ".h\"\n" )
    file.write( "#include \"" + problemBaseName + "Rhs.h\"\n" )    
    file.write( "\n" )
    file.write( "typedef tnlFastBuildConfig BuildConfig;\n" )    
    file.write( "\n" )    
    file.write( "/****\n" )    
    file.write( " * Uncoment the following (and comment the previous line) for the complete build.\n" )    
    file.write( " * This will include support for all floating point precisions, all indexing types\n" )    
    file.write( " * and more solvers. You may then choose between them from the command line.\n" )    
    file.write( " * The compile time may, however, take tens of minutes or even several hours,\n" )    
    file.write( " * esppecially if CUDA is enabled. Use this, if you want, only for the final build,\n" )        
    file.write( " * not in the development phase.\n" )    
    file.write( " */\n" )    
    file.write( "//typedef tnlDefaultConfigTag BuildConfig;\n" )    
    file.write( "\n" )
    file.write( "template< typename ConfigTag >" )
    file.write( "class " + problemBaseName + "Config\n" )
    file.write( "{\n" )
    file.write( "   public:\n" )
    file.write( "      static void configSetup( tnlConfigDescription & config )\n" )
    file.write( "      {\n" )
    file.write( "         config.addDelimiter( \"" + problemName + " settings:\" );\n" )
    file.write( "         config.addEntry< tnlString >( \"boundary-conditions-type\", \"Choose the boundary conditions type.\", \"dirichlet\");\n" )
    file.write( "            config.addEntryEnum< tnlString >( \"dirichlet\" );\n" )
    file.write( "            config.addEntryEnum< tnlString >( \"neumann\" );\n" )
    file.write( "         config.addEntry< double >( \"boundary-conditions-constant\", \"This sets a value in case of the constant boundary conditions.\" );\n" )
    file.write( "\n" )
    file.write( "         /****\n" )
    file.write( "          * Add definition of your solver command line arguments.\n" )
    file.write( "          */\n" )
    file.write( "\n" )
    file.write( "      }\n" )
    file.write( "};\n" )
    file.write( "\n" )
    file.write( "template< typename Real,\n" )
    file.write( "          typename Device,\n" )
    file.write( "          typename Index,\n" )
    file.write( "          typename MeshType,\n" )
    file.write( "          typename ConfigTag,\n" )
    file.write( "          typename SolverStarter >\n" )
    file.write( "class " + problemBaseName + "Setter\n" )
    file.write( "{\n" )
    file.write( "   public:\n" )
    file.write( "\n" )
    file.write( "      typedef Real RealType;\n" )
    file.write( "      typedef Device DeviceType;\n" )
    file.write( "      typedef Index IndexType;\n" )
    file.write( "\n" )
    file.write( "      static bool run( const tnlParameterContainer & parameters )\n" )
    file.write( "      {\n" )
    file.write( "          enum { Dimensions = MeshType::Dimensions };\n" )
    file.write( "          typedef " + operatorName + "< MeshType, Real, Index > ApproximateOperator;\n" )
    file.write( "          typedef " + problemBaseName + "Rhs RightHandSide;\n" )    
    file.write( "          typedef tnlStaticVector < MeshType::Dimensions, Real > Vertex;\n" )
    file.write( "\n" )
    file.write( "         /****\n" )
    file.write( "          * Resolve the template arguments of your solver here.\n" )
    file.write( "          * The following code is for the Dirichlet and the Neumann boundary conditions.\n" )
    file.write( "          * Both can be constant or defined as descrete values of tnlVector.\n" )    
    file.write( "          */\n" )    
    file.write( "          tnlString boundaryConditionsType = parameters.getParameter< tnlString >( \"boundary-conditions-type\" );\n" )
    file.write( "          if( parameters.checkParameter( \"boundary-conditions-constant\" ) )\n" )
    file.write( "          {\n" )
    file.write( "             typedef tnlConstantFunction< Dimensions, Real > ConstantFunction;\n" )
    file.write( "             if( boundaryConditionsType == \"dirichlet\" )\n" )
    file.write( "             {\n" )
    file.write( "                typedef tnlAnalyticDirichletBoundaryConditions< MeshType, ConstantFunction, Real, Index > BoundaryConditions;\n" )
    file.write( "                typedef " + problemBaseName + "Problem< MeshType, BoundaryConditions, RightHandSide, ApproximateOperator > Problem;\n" )
    file.write( "                SolverStarter solverStarter;\n" )
    file.write( "                return solverStarter.template run< Problem >( parameters );\n" )
    file.write( "             }\n" )
    file.write( "             typedef tnlAnalyticNeumannBoundaryConditions< MeshType, ConstantFunction, Real, Index > BoundaryConditions;\n" )
    file.write( "             typedef " + problemBaseName + "Problem< MeshType, BoundaryConditions, RightHandSide, ApproximateOperator > Problem;\n" )
    file.write( "             SolverStarter solverStarter;\n" )
    file.write( "             return solverStarter.template run< Problem >( parameters );\n" )
    file.write( "          }\n" )
    file.write( "          typedef tnlVector< Real, Device, Index > VectorType;\n" )
    file.write( "          if( boundaryConditionsType == \"dirichlet\" )\n" )
    file.write( "          {\n" )
    file.write( "             typedef tnlDirichletBoundaryConditions< MeshType, VectorType, Real, Index > BoundaryConditions;\n" )
    file.write( "             typedef " + problemBaseName + "Problem< MeshType, BoundaryConditions, RightHandSide, ApproximateOperator > Problem;\n" )
    file.write( "             SolverStarter solverStarter;\n" )
    file.write( "             return solverStarter.template run< Problem >( parameters );\n" )
    file.write( "          }\n" )
    file.write( "          typedef tnlNeumannBoundaryConditions< MeshType, VectorType, Real, Index > BoundaryConditions;\n" )
    file.write( "          typedef " + problemBaseName + "Problem< MeshType, BoundaryConditions, RightHandSide, ApproximateOperator > Problem;\n" )
    file.write( "          SolverStarter solverStarter;\n" )
    file.write( "          return solverStarter.template run< Problem >( parameters );\n" )
    file.write( "      }\n" )
    file.write( "\n" )
    file.write( "};\n" )
    file.write( "\n" )
    file.write( "int main( int argc, char* argv[] )\n" )
    file.write( "{\n" )
    file.write( "   tnlSolver< " + problemBaseName + "Setter, " + problemBaseName + "Config, BuildConfig > solver;\n" )
    file.write( "   if( ! solver. run( argc, argv ) )\n" )
    file.write( "      return EXIT_FAILURE;\n" )
    file.write( "   return EXIT_SUCCESS;\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.close()
    file = open( problemBaseName + ".cpp", "w")
    file.write( "#include \"" + problemBaseName + ".h\"\n")
    file.close();
    file = open( problemBaseName + "-cuda.cu", "w")
    file.write( "#include \"" + problemBaseName + ".h\"\n")
    file.close()
    
def generateProblem( problemName, problemBaseName ):
    file = open( problemBaseName + "Problem.h", "w" )
    file.write( "#ifndef " + problemBaseName + "PROBLEM_H_\n" )
    file.write( "#define " + problemBaseName + "PROBLEM_H_\n" )
    file.write( "\n" )
    file.write( "#include <problems/tnlPDEProblem.h>\n")
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "           typename DifferentialOperator >\n" )
    file.write( "class " + problemBaseName + "Problem:\n" )
    file.write( "   public tnlPDEProblem< Mesh,\n" )
    file.write( "                         typename DifferentialOperator::RealType,\n" )
    file.write( "                         typename Mesh::DeviceType,\n" )
    file.write( "                         typename DifferentialOperator::IndexType >\n" )
    file.write( "{\n" )
    file.write( "   public:\n" )
    file.write( "\n" )
    file.write( "      typedef typename DifferentialOperator::RealType RealType;\n" )
    file.write( "      typedef typename Mesh::DeviceType DeviceType;\n" )
    file.write( "      typedef typename DifferentialOperator::IndexType IndexType;\n" )
    file.write( "      typedef tnlPDEProblem< Mesh, RealType, DeviceType, IndexType > BaseType;\n" )
    file.write( "\n" )
    file.write( "      using typename BaseType::MeshType;\n" )
    file.write( "      using typename BaseType::DofVectorType;\n" )
    file.write( "      using typename BaseType::MeshDependentDataType;\n" )
    file.write( "\n" )
    file.write( "      static tnlString getTypeStatic();\n" )
    file.write( "\n" )
    file.write( "      tnlString getPrologHeader() const;\n" )
    file.write( "\n" )
    file.write( "      void writeProlog( tnlLogger& logger,\n" )
    file.write( "                        const tnlParameterContainer& parameters ) const;\n" )
    file.write( "\n" )
    file.write( "      bool setup( const tnlParameterContainer& parameters );\n" )
    file.write( "\n" )
    file.write( "      bool setInitialCondition( const tnlParameterContainer& parameters,\n" )
    file.write( "                                const MeshType& mesh,\n" )
    file.write( "                                DofVectorType& dofs,\n" )
    file.write( "                                MeshDependentDataType& meshDependentData );\n" )
    file.write( "\n" )
    file.write( "      template< typename Matrix >\n" )
    file.write( "      bool setupLinearSystem( const MeshType& mesh,\n" )
    file.write( "                              Matrix& matrix );\n" )
    file.write( "\n" )
    file.write( "      bool makeSnapshot( const RealType& time,\n" )
    file.write( "                         const IndexType& step,\n" )
    file.write( "                         const MeshType& mesh,\n" )
    file.write( "                         DofVectorType& dofs,\n" )
    file.write( "                         MeshDependentDataType& meshDependentData );\n" )
    file.write( "\n" )
    file.write( "      IndexType getDofs( const MeshType& mesh ) const;\n" )
    file.write( "\n" )
    file.write( "      void bindDofs( const MeshType& mesh,\n" )
    file.write( "                     DofVectorType& dofs );\n" )
    file.write( "\n" )
    file.write( "      void getExplicitRHS( const RealType& time,\n" )
    file.write( "                           const RealType& tau,\n" )
    file.write( "                           const MeshType& mesh,\n" )
    file.write( "                           DofVectorType& _u,\n" )
    file.write( "                           DofVectorType& _fu );\n" )
    file.write( "\n" )
    file.write( "      template< typename Matrix >\n" )
    file.write( "      void assemblyLinearSystem( const RealType& time,\n" )
    file.write( "                                 const RealType& tau,\n" )
    file.write( "                                 const MeshType& mesh,\n" )
    file.write( "                                 DofVectorType& dofs,\n" )
    file.write( "                                 DofVectorType& auxDofs,\n" )
    file.write( "                                 Matrix& matrix,\n" )
    file.write( "                                 DofVectorType& rightHandSide );\n" )
    file.write( "\n" )
    file.write( "   protected:\n" )
    file.write( "\n" )    
    file.write( "      DifferentialOperator differentialOperator;\n" )
    file.write( "      BoundaryCondition boundaryCondition;\n" )
    file.write( "      RightHandSide rightHandSide;\n" )
    file.write( "};\n" )
    file.write( "\n" )
    file.write( "#include \"" + problemBaseName + "Problem_impl.h\"\n" )
    file.write( "\n" )
    file.write( "#endif /* " + problemBaseName + "PROBLEM_H_ */\n" )
    file.close()
                                 
    file = open( problemBaseName + "Problem_impl.h", "w" )
    file.write( "#ifndef " + problemBaseName + "PROBLEM_IMPL_H_\n" )
    file.write( "#define " + problemBaseName + "PROBLEM_IMPL_H_\n" )
    file.write( "\n" )
    file.write( "#include <core/mfilename.h>\n" )
    file.write( "#include <matrices/tnlMatrixSetter.h>\n" )
    file.write( "#include <solvers/pde/tnlExplicitUpdater.h>\n" )
    file.write( "#include <solvers/pde/tnlLinearSystemAssembler.h>\n" )
    file.write( "#include <solvers/pde/tnlBackwardTimeDiscretisation.h>\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "tnlString\n" )
    file.write( problemBaseName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )
    file.write( "getTypeStatic()\n" )
    file.write( "{\n" )
    file.write( "   return tnlString( \"" + problemBaseName + "Problem< \" ) + Mesh :: getTypeStatic() + \" >\";\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "tnlString\n" )
    file.write( problemBaseName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )
    file.write( "getPrologHeader() const\n" )
    file.write( "{\n" )    
    file.write( "   return tnlString( \"" + problemName + "\" );\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "void\n" )
    file.write( problemBaseName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )    
    file.write( "writeProlog( tnlLogger& logger, const tnlParameterContainer& parameters ) const\n" )
    file.write( "{\n" )
    file.write( "   /****\n" )
    file.write( "    * Add data you want to have in the computation report (log) as follows:\n" )
    file.write( "    * logger.writeParameter< double >( \"Parameter description\", parameter );\n" )
    file.write( "    */\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "bool\n" )
    file.write( problemBaseName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )        
    file.write( "setup( const tnlParameterContainer& parameters )\n" )
    file.write( "{\n" )
    file.write( "   if( ! this->boundaryCondition.setup( parameters, \"boundary-conditions-\" ) ||\n" )
    file.write( "       ! this->rightHandSide.setup( parameters, \"right-hand-side-\" ) )\n" )
    file.write( "      return false;\n" )
    file.write( "   return true;\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "typename " + problemBaseName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::IndexType\n" )
    file.write( problemBaseName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )            
    file.write( "getDofs( const MeshType& mesh ) const\n" )
    file.write( "{\n" )
    file.write( "   /****\n" )
    file.write( "    * Return number of  DOFs (degrees of freedom) i.e. number\n" )
    file.write( "    * of unknowns to be resolved by the main solver.\n" )
    file.write( "    */\n" )
    file.write( "   return mesh.getNumberOfCells();\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "void\n" )
    file.write( problemBaseName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )            
    file.write( "bindDofs( const MeshType& mesh,\n" )
    file.write( "          DofVectorType& dofVector )\n" )    
    file.write( "{\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "bool\n" )
    file.write( problemBaseName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )            
    file.write( "setInitialCondition( const tnlParameterContainer& parameters,\n" )    
    file.write( "                     const MeshType& mesh,\n" )
    file.write( "                     DofVectorType& dofs,\n" )
    file.write( "                     MeshDependentDataType& meshDependentData )\n" )
    file.write( "{\n" )
    file.write( "   const tnlString& initialConditionFile = parameters.getParameter< tnlString >( \"initial-condition\" );\n" )
    file.write( "   if( ! dofs.load( initialConditionFile ) )\n" )
    file.write( "   {\n" )
    file.write( "      cerr << \"I am not able to load the initial condition from the file \" << initialConditionFile << \".\" << endl;\n" )
    file.write( "      return false;\n" )
    file.write( "   }\n" )
    file.write( "   return true; \n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "   template< typename Matrix >\n" )
    file.write( "bool\n" )
    file.write( problemBaseName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )                
    file.write( "setupLinearSystem( const MeshType& mesh,\n" )
    file.write( "                   Matrix& matrix )\n" )
    file.write( "{\n" )
    file.write( "   const IndexType dofs = this->getDofs( mesh );\n" )
    file.write( "   typedef typename Matrix::RowLengthsVector RowLengthsVectorType;\n" )
    file.write( "   RowLengthsVectorType rowLengths;\n" )
    file.write( "   if( ! rowLengths.setSize( dofs ) )\n" )
    file.write( "      return false;\n" )
    file.write( "   tnlMatrixSetter< MeshType, DifferentialOperator, BoundaryCondition, RowLengthsVectorType > matrixSetter;\n" )
    file.write( "   matrixSetter.template getRowLengths< Mesh::Dimensions >( mesh,\n" )
    file.write( "                                                            differentialOperator,\n" )
    file.write( "                                                            boundaryCondition,\n" )
    file.write( "                                                            rowLengths );\n" )
    file.write( "   matrix.setDimensions( dofs, dofs );\n" )
    file.write( "   if( ! matrix.setRowLengths( rowLengths ) )\n" )
    file.write( "      return false;\n" )
    file.write( "   return true;\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "bool\n" )
    file.write( problemBaseName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )                    
    file.write( "makeSnapshot( const RealType& time,\n" )
    file.write( "              const IndexType& step,\n" )
    file.write( "              const MeshType& mesh,\n" )
    file.write( "              DofVectorType& dofs,\n" )
    file.write( "              MeshDependentDataType& meshDependentData )\n" )
    file.write( "{\n" )
    file.write( "   cout << endl << \"Writing output at time \" << time << \" step \" << step << \".\" << endl;\n" )
    file.write( "   this->bindDofs( mesh, dofs );\n" )
    file.write( "   tnlString fileName;\n" )
    file.write( "   FileNameBaseNumberEnding( \"u-\", step, 5, \".tnl\", fileName );\n" )
    file.write( "   if( ! dofs.save( fileName ) )\n" )
    file.write( "      return false;\n" )
    file.write( "   return true;\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "void\n" )
    file.write( problemBaseName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )                    
    file.write( "getExplicitRHS( const RealType& time,\n" )
    file.write( "                const RealType& tau,\n" )
    file.write( "                const MeshType& mesh,\n" )
    file.write( "                DofVectorType& u,\n" )
    file.write( "                DofVectorType& fu )\n" )
    file.write( "{\n" )
    file.write( "   /****\n" )
    file.write( "    * If you use an explicit solver like tnlEulerSolver or tnlMersonSolver, you\n" )
    file.write( "    * need to implement this method. Compute the right-hand side of\n" )
    file.write( "    *\n" )
    file.write( "    *   d/dt u(x) = fu( x, u )\n" )
    file.write( "    *\n" )
    file.write( "    * You may use supporting mesh dependent data if you need.\n" )
    file.write( "    */\n" )
    file.write( "\n" )
    file.write( "   this->bindDofs( mesh, u );\n" )
    file.write( "   tnlExplicitUpdater< Mesh, DofVectorType, DifferentialOperator, BoundaryCondition, RightHandSide > explicitUpdater;\n" )
    file.write( "   explicitUpdater.template update< Mesh::Dimensions >( time,\n" )
    file.write( "                                                        mesh,\n" )
    file.write( "                                                        this->differentialOperator,\n" )
    file.write( "                                                        this->boundaryCondition,\n" )
    file.write( "                                                        this->rightHandSide,\n" )
    file.write( "                                                        u,\n" )
    file.write( "                                                        fu );\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "   template< typename Matrix >\n" )
    file.write( "void\n" )
    file.write( problemBaseName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )                
    file.write( "assemblyLinearSystem( const RealType& time,\n" )
    file.write( "                      const RealType& tau,\n" )
    file.write( "                      const MeshType& mesh,\n" )
    file.write( "                      DofVectorType& u,\n" )
    file.write( "                      DofVectorType& auxDofs,\n" )
    file.write( "                      Matrix& matrix,\n" )
    file.write( "                      DofVectorType& b )\n" )
    file.write( "{\n" )
    file.write( "   tnlLinearSystemAssembler< Mesh,\n" )
    file.write( "                             DofVectorType,\n" )
    file.write( "                             DifferentialOperator,\n" )
    file.write( "                             BoundaryCondition,\n" )
    file.write( "                             RightHandSide,\n" )
    file.write( "                             tnlBackwardTimeDiscretisation,\n" )
    file.write( "                             Matrix > systemAssembler;\n" )
    file.write( "   systemAssembler.template assembly< Mesh::Dimensions >( time,\n" )
    file.write( "                                                          tau,\n" )
    file.write( "                                                          mesh,\n" )
    file.write( "                                                          this->differentialOperator,\n" )
    file.write( "                                                          this->boundaryCondition,\n" )
    file.write( "                                                          this->rightHandSide,\n" )
    file.write( "                                                          u,\n" )
    file.write( "                                                          matrix,\n" )
    file.write( "                                                          b );\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "#endif /* " + problemBaseName + "PROBLEM_IMPL_H_ */\n" )
    file.close()

def generateOperatorGridSpecializationHeader( file, operatorName, dimensions ):
    file.write( "template< typename MeshReal,\n" )
    file.write( "          typename Device,\n" )
    file.write( "          typename MeshIndex,\n" )
    file.write( "          typename Real,\n" )
    file.write( "          typename Index >\n" )
    file.write( "class " + operatorName + "< tnlGrid< " + dimensions + ",MeshReal, Device, MeshIndex >, Real, Index >\n" )
    file.write( "{\n" )
    file.write( "   public:\n" )
    file.write( "      typedef tnlGrid< " + dimensions + ", MeshReal, Device, MeshIndex > MeshType;\n" )
    file.write( "      typedef typename MeshType::CoordinatesType CoordinatesType;\n" )
    file.write( "      typedef Real RealType;\n" )
    file.write( "      typedef Device DeviceType;\n" )
    file.write( "      typedef Index IndexType;\n" )
    file.write( "      enum { Dimensions = MeshType::Dimensions };\n" )
    file.write( "\n" )
    file.write( "      static tnlString getType();\n" )
    file.write( "\n" )
    file.write( "      template< typename Vector >\n" )
    file.write( "      __cuda_callable__\n" )
    file.write( "      Real getValue( const MeshType& mesh,\n" )
    file.write( "                     const IndexType cellIndex,\n" )
    file.write( "                     const CoordinatesType& coordinates,\n" )
    file.write( "                     const Vector& u,\n" )
    file.write( "                     const RealType& time ) const;\n" )
    file.write( "\n" )
    file.write( "      __cuda_callable__\n" )
    file.write( "      Index getLinearSystemRowLength( const MeshType& mesh,\n" )
    file.write( "                                      const IndexType& index,\n" )
    file.write( "                                      const CoordinatesType& coordinates ) const;\n" )
    file.write( "\n" )
    file.write( "      template< typename Vector, typename MatrixRow >\n" )
    file.write( "      __cuda_callable__\n" )
    file.write( "      void updateLinearSystem( const RealType& time,\n" )
    file.write( "                               const RealType& tau,\n" )
    file.write( "                               const MeshType& mesh,\n" )
    file.write( "                               const IndexType& index,\n" )
    file.write( "                               const CoordinatesType& coordinates,\n" )
    file.write( "                               Vector& u,\n" )
    file.write( "                               Vector& b,\n" )
    file.write( "                               MatrixRow& matrixRow ) const;\n" )
    file.write( "};\n" )
    file.write( "\n" )    
    
def generateOperatorGridSpecializationImplementation( file, operatorName, dimensions ):
    file.write( "template< typename MeshReal,\n" )
    file.write( "          typename Device,\n" )
    file.write( "          typename MeshIndex,\n" )
    file.write( "          typename Real,\n" )
    file.write( "          typename Index >\n" )
    file.write( "tnlString\n" )
    file.write( operatorName + "< tnlGrid< " + dimensions + ", MeshReal, Device, MeshIndex >, Real, Index >::\n" )
    file.write( "getType()\n" )
    file.write( "{\n" )
    file.write( "   return tnlString( \"" + operatorName + "< \" ) +\n" )
    file.write( "          MeshType::getType() + \", \" +\n" )
    file.write( "          ::getType< Real >() + \", \" +\n" )
    file.write( "          ::getType< Index >() + \" >\";\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename MeshReal,\n" )
    file.write( "          typename Device,\n" )
    file.write( "          typename MeshIndex,\n" )
    file.write( "          typename Real,\n" )
    file.write( "          typename Index >\n" )    
    file.write( "template< typename Vector >\n" )
    file.write( "__cuda_callable__\n" )
    file.write( "Real\n" )
    file.write( operatorName + "< tnlGrid< " + dimensions + ", MeshReal, Device, MeshIndex >, Real, Index >::\n" )
    file.write( "getValue( const MeshType& mesh,\n" )
    file.write( "          const IndexType cellIndex,\n" )
    file.write( "          const CoordinatesType& coordinates,\n" )
    file.write( "          const Vector& u,\n" )
    file.write( "          const Real& time ) const\n" )
    file.write( "{\n" )
    file.write( "   /****\n" )
    file.write( "    * Implement your explicit form of the differential operator here.\n" )
    file.write( "    * The following example is the Laplace operator approximated \n" )
    file.write( "    * by the Finite difference method.\n" )
    file.write( "    */\n" )    
    file.write( "\n" )
    if dimensions == "1":
        file.write( "   return ( u[ mesh.template getCellNextToCell< -1 >( cellIndex ) ]\n" )
        file.write( "            - 2.0 * u[ cellIndex ]\n" )
        file.write( "            + u[ mesh.template getCellNextToCell< 1 >( cellIndex ) ] ) * mesh.getHxSquareInverse();\n" )
    if dimensions == "2":
        file.write( "   return ( u[ mesh.template getCellNextToCell< -1, 0 >( cellIndex ) ]\n" )
        file.write( "            - 2.0 * u[ cellIndex ]\n" )
        file.write( "            + u[ mesh.template getCellNextToCell< 1, 0 >( cellIndex ) ] ) * mesh.getHxSquareInverse() +\n" )
        file.write( "           ( u[ mesh.template getCellNextToCell< 0, -1 >( cellIndex ) ]\n" )
        file.write( "             - 2.0 * u[ cellIndex ]\n" )
        file.write( "             + u[ mesh.template getCellNextToCell< 0, 1 >( cellIndex ) ] ) * mesh.getHySquareInverse();\n" )
    if dimensions == "3":
        file.write( "   return ( u[ mesh.template getCellNextToCell< -1, 0, 0 >( cellIndex ) ]\n" )
        file.write( "            - 2.0 * u[ cellIndex ]\n" )
        file.write( "            + u[ mesh.template getCellNextToCell< 1, 0, 0 >( cellIndex ) ] ) * mesh.getHxSquareInverse() +\n" )
        file.write( "          ( u[ mesh.template getCellNextToCell< 0, -1, 0 >( cellIndex ) ]\n" )
        file.write( "            - 2.0 * u[ cellIndex ]\n" )
        file.write( "            + u[ mesh.template getCellNextToCell< 0, 1, 0 >( cellIndex ) ] ) * mesh.getHySquareInverse() +\n" )
        file.write( "          ( u[ mesh.template getCellNextToCell< 0, 0, -1 >( cellIndex ) ]\n" )
        file.write( "            - 2.0 * u[ cellIndex ]\n" )
        file.write( "            + u[ mesh.template getCellNextToCell< 0, 0, 1 >( cellIndex ) ] ) * mesh.getHzSquareInverse();\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename MeshReal,\n" )
    file.write( "          typename Device,\n" )
    file.write( "          typename MeshIndex,\n" )
    file.write( "          typename Real,\n" )
    file.write( "          typename Index >\n" )        
    file.write( "__cuda_callable__\n" )
    file.write( "Index\n" )
    file.write( operatorName + "< tnlGrid< " + dimensions + ", MeshReal, Device, MeshIndex >, Real, Index >::\n" )
    file.write( "getLinearSystemRowLength( const MeshType& mesh,\n" )
    file.write( "                          const IndexType& index,\n" )
    file.write( "                          const CoordinatesType& coordinates ) const\n" )
    file.write( "{\n" )
    file.write( "   /****\n" )
    file.write( "    * Return a number of non-zero elements in a line (associated with given grid element) of\n" )
    file.write( "    * the linear system.\n" )
    file.write( "    * The following example is the Laplace operator approximated \n" )
    file.write( "    * by the Finite difference method.\n" )
    file.write( "    */\n" )
    file.write( "\n" )
    file.write( "   return 2*Dimensions + 1;\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename MeshReal,\n" )
    file.write( "          typename Device,\n" )
    file.write( "          typename MeshIndex,\n" )
    file.write( "          typename Real,\n" )
    file.write( "          typename Index >\n" )
    file.write( "   template< typename Vector, typename MatrixRow >\n" )       
    file.write( "__cuda_callable__\n" )        
    file.write( "void\n" )
    file.write( operatorName + "< tnlGrid< " + dimensions + ", MeshReal, Device, MeshIndex >, Real, Index >::\n" )
    file.write( "updateLinearSystem( const RealType& time,\n" )
    file.write( "                    const RealType& tau,\n" )
    file.write( "                    const MeshType& mesh,\n" )
    file.write( "                    const IndexType& index,\n" )
    file.write( "                    const CoordinatesType& coordinates,\n" )
    file.write( "                    Vector& u,\n" )
    file.write( "                    Vector& b,\n" )
    file.write( "                    MatrixRow& matrixRow ) const\n" )
    file.write( "{\n" )
    file.write( "   /****\n" )
    file.write( "    * Setup the non-zero elements of the linear system here.\n" )
    file.write( "    * The following example is the Laplace operator appriximated \n" )
    file.write( "    * by the Finite difference method.\n" )
    file.write( "    */\n" )    
    file.write( "\n" )
    if dimensions == "1":
       file.write( "   const RealType lambdaX = tau * mesh.getHxSquareInverse();\n" )
       file.write( "   matrixRow.setElement( 0, mesh.template getCellNextToCell< -1 >( index ),     - lambdaX );\n" )
       file.write( "   matrixRow.setElement( 1, index,                             2.0 * lambdaX );\n" )
       file.write( "   matrixRow.setElement( 2, mesh.template getCellNextToCell< 1 >( index ),       - lambdaX );\n" )
    if dimensions == "2":
        file.write( "   const RealType lambdaX = tau * mesh.getHxSquareInverse();\n" )
        file.write( "   const RealType lambdaY = tau * mesh.getHySquareInverse();\n" )
        file.write( "   matrixRow.setElement( 0, mesh.template getCellNextToCell< 0, -1 >( index ), -lambdaY );\n" )
        file.write( "   matrixRow.setElement( 1, mesh.template getCellNextToCell< -1, 0 >( index ), -lambdaX );\n" )
        file.write( "   matrixRow.setElement( 2, index,                                             2.0 * ( lambdaX + lambdaY ) );\n" )
        file.write( "   matrixRow.setElement( 3, mesh.template getCellNextToCell< 1, 0 >( index ),   -lambdaX );\n" )
        file.write( "   matrixRow.setElement( 4, mesh.template getCellNextToCell< 0, 1 >( index ),   -lambdaY );\n" )
    if dimensions == "3":        
        file.write( "   const RealType lambdaX = tau * mesh.getHxSquareInverse();\n" )
        file.write( "   const RealType lambdaY = tau * mesh.getHySquareInverse();\n" )
        file.write( "   const RealType lambdaZ = tau * mesh.getHzSquareInverse();\n" )
        file.write( "   matrixRow.setElement( 0, mesh.template getCellNextToCell< 0, 0, -1 >( index ), -lambdaZ );\n" )
        file.write( "   matrixRow.setElement( 1, mesh.template getCellNextToCell< 0, -1, 0 >( index ), -lambdaY );\n" )
        file.write( "   matrixRow.setElement( 2, mesh.template getCellNextToCell< -1, 0, 0 >( index ), -lambdaX );\n" )
        file.write( "   matrixRow.setElement( 3, index,                             2.0 * ( lambdaX + lambdaY + lambdaZ ) );\n" )
        file.write( "   matrixRow.setElement( 4, mesh.template getCellNextToCell< 1, 0, 0 >( index ),   -lambdaX );\n" )
        file.write( "   matrixRow.setElement( 5, mesh.template getCellNextToCell< 0, 1, 0 >( index ),   -lambdaY );\n" )
        file.write( "   matrixRow.setElement( 6, mesh.template getCellNextToCell< 0, 0, 1 >( index ),   -lambdaZ );\n" )
    file.write( "}\n" )
    file.write( "\n" )
    
def generateOperator( operatorName):
    file = open( operatorName + ".h", "w" )    
    file.write( "#ifndef " + operatorName + "_H\n" )
    file.write( "#define " + operatorName + "_H\n" )
    file.write( "\n" )
    file.write( "#include <core/vectors/tnlVector.h>\n" )
    file.write( "#include <mesh/tnlGrid.h>\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename Real = typename Mesh::RealType,\n" )
    file.write( "          typename Index = typename Mesh::IndexType >\n" )
    file.write( "class " + operatorName + "\n" )
    file.write( "{\n" )
    file.write( "};\n" )
    file.write( "\n" )
    generateOperatorGridSpecializationHeader( file, operatorName, "1" )
    generateOperatorGridSpecializationHeader( file, operatorName, "2" )
    generateOperatorGridSpecializationHeader( file, operatorName, "3" )
    file.write( "\n" )
    file.write( "#include \""+ operatorName + "_impl.h\"\n" )
    file.write( "\n" )
    file.write( "#endif	/* " + operatorName + "_H */\n" )
    file.close()
    file = open( operatorName + "_impl.h", "w" )    
    file.write( "#ifndef " + operatorName + "_IMPL_H\n" )
    file.write( "#define " + operatorName + "_IMPL_H\n" )
    file.write( "\n" )
    file.write( "/****\n" )
    file.write( " * 1D problem\n" )
    file.write( " */\n" )
    generateOperatorGridSpecializationImplementation( file, operatorName, "1" )
    file.write( "/****\n" )
    file.write( " * 2D problem\n" )
    file.write( " */\n" )
    generateOperatorGridSpecializationImplementation( file, operatorName, "2" )
    file.write( "/****\n" )
    file.write( " * 3D problem\n" )
    file.write( " */\n" )    
    generateOperatorGridSpecializationImplementation( file, operatorName, "3" )
    file.write( "#endif	/* " + operatorName + "IMPL_H */\n" )
    file.write( "\n" )
    file.close()
    
def generateRhs( problemBaseName ):
    file = open( problemBaseName + "Rhs.h", "w" )
    file.write( "#ifndef " + problemBaseName + "RHS_H_\n" )
    file.write( "#define " + problemBaseName + "RHS_H_\n" )
    file.write( "\n" )
    file.write( "class " + problemBaseName + "Rhs\n" )
    file.write( "{\n" )
    file.write( "   public:\n" )
    file.write( "      bool setup( const tnlParameterContainer& parameters,\n" )
    file.write( "                  const tnlString& prefix = \"\" )\n" )
    file.write( "      {\n" )
    file.write( "         return true;\n" )
    file.write( "      }\n" )
    file.write( "\n" )
    file.write( "      template< typename Mesh,\n" )
    file.write( "                typename Index,\n" )
    file.write( "                typename Real >\n" )
    file.write( "      __cuda_callable__\n" )
    file.write( "      Real getValue( const Mesh& mesh,\n" )
    file.write( "                     const Index& index,\n" )
    file.write( "                     const Real& time ) const\n" )    
    file.write( "      {\n" )    
    file.write( "         typedef typename Mesh::VertexType VertexType;\n" )
    file.write( "         VertexType v = mesh.template getCellCenter< VertexType >( index );\n" )        
    file.write( "         return 0.0;\n" )    
    file.write( "      };\n" )    
    file.write( "};\n" )    
    file.write( "\n" )    
    file.write( "#endif /* " + problemBaseName + "RHS_H_ */\n" )    
    file.close()

def generateRunScript( problemBaseName ):
    file = open( "run-" + problemBaseName, "w" )
    file.write( "#!/usr/bin/env bash\n" ) 
    file.write( "\n" ) 
    file.write( "tnl-grid-setup --dimensions 2 \\\n" ) 
    file.write( "               --origin-x 0.0 \\\n" ) 
    file.write( "               --origin-y 0.0 \\\n" ) 
    file.write( "               --proportions-x 1.0 \\\n" ) 
    file.write( "               --proportions-y 1.0 \\\n" ) 
    file.write( "               --size-x 100 \\\n" ) 
    file.write( "               --size-y 100\n" ) 
    file.write( "\n" ) 
    file.write( "tnl-init --test-function sin-wave \\\n" ) 
    file.write( "         --output-file init.tnl\n" ) 
    file.write( "./" + problemName + " --time-discretisation explicit \\\n" ) 
    file.write( "              --discrete-solver merson \\\n" ) 
    file.write( "              --snapshot-period 0.01 \\\n" ) 
    file.write( "              --final-time 1.0\n" ) 
    file.write( "\n" ) 
    file.write( "tnl-view --mesh mesh.tnl --input-files *tnl     \n" ) 
    file.close()
    
print( "TNL Quickstart -- solver generator")
print( "----------------------------------")
problemName = input( "Problam name:" )
problemBaseName = input( "Problem class base name (base name acceptable in C++ code):" )
operatorName = input( "Operator name:")
generateMakefile( problemBaseName )
generateMain( problemName, problemBaseName, operatorName )
generateProblem( problemName, problemBaseName )
generateOperator( operatorName )
generateRhs( problemBaseName )
generateRunScript( problemBaseName )