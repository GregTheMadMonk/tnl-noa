#! /usr/bin/python

# To change this license header, choose License Headers in Project Properties.
# To change this template file, choose Tools | Templates
# and open the template in the editor.

__author__ = "oberhuber"
__date__ = "$May 6, 2015 8:40:59 PM$"


def generateMakefile( problemName ):
    file = open( "Makefile", "w" )
    file.write( "TARGET = " + problemName + "\n")
    file.write( "INSTALL_DIR = ${HOME}/local\n" )
    file.write( "\n" )
    file.write( "CXX = g++\n" ) 
    file.write( "CUDA_CXX = nvcc\n" ) 
    file.write( "CXX_FLAGS = $(shell tnl-compile)\n" )
    file.write( "CUDA_CXX_FLAGS = $(shell tnl-compile --cuda)\n" )
    file.write( "LD_FLAGS = $(shell tnl-link )\n" )
    file.write( "\n" )
    file.write( "SOURCES = " + problemName + ".cpp\n" )
    file.write( "CUDA_SOURCES = " + problemName + ".cu\n" )
    file.write( "HEADERS = " + problemName + ".h\n" )
    file.write( "OBJECTS = " + problemName + ".o\n" ) 
    file.write( "DIST = $(SOURCES) $(CUDA_SOURCES) $(HEADERS) Makefile\n" ) 
    file.write( "\n" ) 
    file.write( "all: $(TARGET)\n" ) 
    file.write( "\n" ) 
    file.write( "clean:\n" ) 
    file.write( "\t rm -f $(OBJECTS)" ) 
    file.write( "\n" ) 
    file.write( "dist: $(DIST)" ) 
    file.write( "\t tar zcvf $(TARGET).tgz $(DIST)\n" ) 
    file.write( "\n" ) 
    file.write( "$(TARGET): % : %.o\n" ) 
    file.write( "\t$(CXX) -o $@ $< $(LDFLAGS)\n" ) 
    file.write( "\n" ) 
    file.write( "%.o: %.cpp\n" ) 
    file.write( "\t $(CXX) $(CPPFLAGS) $(CXX_FLAGS) -c -o $@ $<" ) 
    file.close()

def generateMain( projectName, problemName ):
    file = open( problemName + ".h", "w" )
    file.write( "#include <tnlConfig.h>\n" )
    file.write( "#include <solvers/tnlSolver.h>\n" )
    file.write( "#include <solvers/tnlConfigTags.h>\n" )
    file.write( "\n" )
    file.write( "typedef tnlDefaultConfigTag BuildConfig;\n" )
    file.write( "\n" )
    file.write( "template< typename ConfigTag >" )
    file.write( "class " + problemName + "Config\n" )
    file.write( "{\n" )
    file.write( "   public:\n" )
    file.write( "      static void configSetup( tnlConfigDescription & config )\n" )
    file.write( "      {\n" )
    file.write( "         config.addDelimiter( \"" + projectName + " settings:\" );\n" )
    file.write( "\n" )
    file.write( "         /****\n" )
    file.write( "          * Add definition of your solver command line arguments.\n" )
    file.write( "          */\n" )
    file.write( "\n" )
    file.write( "      }\n" )
    file.write( "};\n" )
    file.write( "\n" )
    file.write( "template< typename Real,\n" )
    file.write( "          typename Device,\n" )
    file.write( "          typename Index,\n" )
    file.write( "          typename MeshType,\n" )
    file.write( "          typename ConfigTag,\n" )
    file.write( "          typename SolverStarter >\n" )
    file.write( "class " + problemName + "Setter\n" )
    file.write( "{\n" )
    file.write( "   public:\n" )
    file.write( "\n" )
    file.write( "      typedef Real RealType;\n" )
    file.write( "      typedef Device DeviceType;\n" )
    file.write( "      typedef Index IndexType;\n" )
    file.write( "\n" )
    file.write( "      static bool run( const tnlParameterContainer & parameters )\n" )
    file.write( "      {\n" )
    file.write( "         typedef " + problemName + "Problem< MeshType > Problem;\n" )
    file.write( "\n" )
    file.write( "         /****\n" )
    file.write( "          * Resolve other template arguments of your solver here if necessary.\n" )
    file.write( "          */\n" )
    file.write( "\n" )
    file.write( "         SolverStarter solverStarter;\n" )
    file.write( "         return solverStarter.template run< Problem >( parameters );\n" )
    file.write( "      }\n" )
    file.write( "\n" )
    file.write( "};\n" )
    file.write( "\n" )
    file.write( "int main( int argc, char* argv[] )\n" )
    file.write( "{\n" )
    file.write( "   tnlSolver< " + problemName + "Setter, " + problemName + "Config, BuildConfig > solver;\n" )
    file.write( "   if( ! solver. run( argc, argv ) )\n" )
    file.write( "      return EXIT_FAILURE;\n" )
    file.write( "   return EXIT_SUCCESS;\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.close()
    file = open( problemName + ".cpp", "w")
    file.write( "#include \"" + problemName + ".h\"\n")
    file.close();
    file = open( problemName + ".cu", "w")
    file.write( "#include \"" + problemName + ".h\"\n")
    file.close()
    
def generateProblem( projectName, problemName ):
    file = open( problemName + "Problem.h", "w" )
    file.write( "#ifndef " + problemName + "PROBLEM_H_\n" )
    file.write( "#define " + problemName + "PROBLEM_H_\n" )
    file.write( "\n" )
    file.write( "#include <problems/tnlPDEProblem.h>\n")
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "           typename DifferentialOperator >\n" )
    file.write( "class " + problemName + "Problem:\n" )
    file.write( "   public tnlPDEProblem< Mesh,\n" )
    file.write( "                         typename DifferentialOperator::RealType,\n" )
    file.write( "                         typename Mesh::DeviceType,\n" )
    file.write( "                         typename DifferentialOperator::IndexType >\n" )
    file.write( "{\n" )
    file.write( "\n" )
    file.write( "   public:\n" )
    file.write( "\n" )
    file.write( "      typedef typename DifferentialOperator::RealType RealType;\n" )
    file.write( "      typedef typename Mesh::DeviceType DeviceType;\n" )
    file.write( "      typedef typename DifferentialOperator::IndexType IndexType;\n" )
    file.write( "      typedef tnlPDEProblem< Mesh, RealType, DeviceType, IndexType > BaseType;\n" )
    file.write( "\n" )
    file.write( "      using typename BaseType::MeshType;\n" )
    file.write( "      using typename BaseType::DofVectorType;\n" )
    file.write( "      using typename BaseType::MeshDependentDataType;\n" )
    file.write( "\n" )
    file.write( "      static tnlString getTypeStatic();\n" )
    file.write( "\n" )
    file.write( "      tnlString getPrologHeader() const;\n" )
    file.write( "\n" )
    file.write( "      void writeProlog( tnlLogger& logger,\n" )
    file.write( "                        const tnlParameterContainer& parameters ) const;\n" )
    file.write( "\n" )
    file.write( "      bool setup( const tnlParameterContainer& parameters );\n" )
    file.write( "\n" )
    file.write( "      bool setInitialCondition( const tnlParameterContainer& parameters,\n" )
    file.write( "                                const MeshType& mesh,\n" )
    file.write( "                                DofVectorType& dofs,\n" )
    file.write( "                                MeshDependentDataType& meshDependentData );\n" )
    file.write( "\n" )
    file.write( "      template< typename Matrix >\n" )
    file.write( "      bool setupLinearSystem( const MeshType& mesh,\n" )
    file.write( "                              Matrix& matrix );\n" )
    file.write( "\n" )
    file.write( "      bool makeSnapshot( const RealType& time,\n" )
    file.write( "                         const IndexType& step,\n" )
    file.write( "                         const MeshType& mesh,\n" )
    file.write( "                         DofVectorType& dofs,\n" )
    file.write( "                         MeshDependentDataType& meshDependentData );\n" )
    file.write( "\n" )
    file.write( "      IndexType getDofs( const MeshType& mesh ) const;\n" )
    file.write( "\n" )
    file.write( "      void bindDofs( const MeshType& mesh,\n" )
    file.write( "                     DofVectorType& dofs );\n" )
    file.write( "\n" )
    file.write( "      void getExplicitRHS( const RealType& time,\n" )
    file.write( "                           const RealType& tau,\n" )
    file.write( "                           const MeshType& mesh,\n" )
    file.write( "                           DofVectorType& _u,\n" )
    file.write( "                           DofVectorType& _fu );\n" )
    file.write( "\n" )
    file.write( "      template< typename Matrix >\n" )
    file.write( "      void assemblyLinearSystem( const RealType& time,\n" )
    file.write( "                                 const RealType& tau,\n" )
    file.write( "                                 const MeshType& mesh,\n" )
    file.write( "                                 DofVectorType& dofs,\n" )
    file.write( "                                 DofVectorType& auxDofs,\n" )
    file.write( "                                 Matrix& matrix,\n" )
    file.write( "                                 DofVectorType& rightHandSide );\n" )
    file.write( "\n" )
    file.write( "   protected:\n" )
    file.write( "\n" )    
    file.write( "      DifferentialOperator differentialOperator;\n" )
    file.write( "      BoundaryCondition boundaryCondition;\n" )
    file.write( "      RightHandSide rightHandSide;\n" )
    file.write( "\n" )
    file.write( "#include \"" + problemName + "Problem_impl.h\"\n" )
    file.write( "\n" )
    file.write( "#endif /* " + problemName + "PROBLEM_H_ */\n" )
    file.close()
                                 
    file = open( problemName + "Problem_impl.h", "w" )
    file.write( "#ifndef " + problemName + "PROBLEM_IMPL_H_\n" )
    file.write( "#define " + problemName + "PROBLEM_IMPL_H_\n" )
    file.write( "\n" )
    file.write( "#include <core/mfilename.h>\n" )
    file.write( "#include <matrices/tnlMatrixSetter.h>\n" )
    file.write( "#include <solvers/pde/tnlExplicitUpdater.h>\n" )
    file.write( "#include <solvers/pde/tnlExplicitUpdater.h>\n" )
    file.write( "#include <solvers/pde/tnlBackwardTimeDiscretisation.h>\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "tnlString\n" )
    file.write( problemName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )
    file.write( "getTypeStatic()\n" )
    file.write( "{\n" )
    file.write( "   return tnlString( \"" + problemName + "Problem< \" ) + Mesh :: getTypeStatic() + \" >\";\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "tnlString\n" )
    file.write( problemName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )
    file.write( "getPrologHeader() const\n" )
    file.write( "{\n" )    
    file.write( "   return tnlString( \"" + projectName + "\" );\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "void\n" )
    file.write( problemName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )    
    file.write( "writeProlog( tnlLogger& logger, const tnlParameterContainer& parameters ) const\n" )
    file.write( "{\n" )
    file.write( "   /****\n" )
    file.write( "    * Add data you want to have in the computation report (log) as follows:\n" )
    file.write( "    * logger.writeParameter< double >( \"Parameter description\", parameter );\n" )
    file.write( "    */\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "bool\n" )
    file.write( problemName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )        
    file.write( "setup( const tnlParameterContainer& parameters )\n" )
    file.write( "{\n" )
    file.write( "   if( ! this->boundaryCondition.setup( parameters, \"boundary-conditions-\" ) ||\n" )
    file.write( "       ! this->rightHandSide.setup( parameters, \"right-hand-side-\" ) )\n" )
    file.write( "      return false;\n" )
    file.write( "   return true;\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "typename " + problemName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::IndexType\n" )
    file.write( problemName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )            
    file.write( "getDofs( const MeshType& mesh ) const\n" )
    file.write( "{\n" )
    file.write( "   /****\n" )
    file.write( "    * Set-up DOFs and supporting grid functions\n" )
    file.write( "    */\n" )
    file.write( "   return mesh.getNumberOfCells();\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "void\n" )
    file.write( problemName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )            
    file.write( "bindDofs( const MeshType& mesh,\n" )
    file.write( "          DofVectorType& dofVector )\n" )    
    file.write( "{\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "bool\n" )
    file.write( problemName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )            
    file.write( "setInitialCondiiton( const tnlParameterContainer& parameters,\n" )    
    file.write( "                     const MeshType& mesh,\n" )
    file.write( "                     DofVectorType& dofs,\n" )
    file.write( "                     MeshDependentDataType& meshDependentData )\n" )
    file.write( "{\n" )
    file.write( "   const tnlString& initialConditionFile = parameters.getParameter< tnlString >( \"initial-condition\" );\n" )
    file.write( "   if( ! dofs.load( initialConditionFile ) )\n" )
    file.write( "   {\n" )
    file.write( "      cerr << \"I am not able to load the initial condition from the file \" << initialConditionFile << \".\" << endl;\n" )
    file.write( "      return false;\n" )
    file.write( "   }\n" )
    file.write( "   return true; \n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "template< typename Mesh,\n" )
    file.write( "          typename BoundaryCondition,\n" )
    file.write( "          typename RightHandSide,\n" )
    file.write( "          typename DifferentialOperator >\n" )
    file.write( "   template< typename Matrix >\n" )
    file.write( "bool\n" )
    file.write( problemName + "Problem< Mesh, BoundaryCondition, RightHandSide, DifferentialOperator >::\n" )                
    file.write( "setupLinearSystem( const MeshType& mesh,\n" )
    file.write( "                   Matrix& matrix )\n" )
    file.write( "{\n" )
    file.write( "   const IndexType dofs = this->getDofs( mesh );\n" )
    file.write( "   typedef typename Matrix::RowLengthsVector RowLengthsVectorType;\n" )
    file.write( "   RowLengthsVectorType rowLengths;\n" )
    file.write( "   if( ! rowLengths.setSize( dofs ) )\n" )
    file.write( "      return false;\n" )
    file.write( "   tnlMatrixSetter< MeshType, DifferentialOperator, BoundaryCondition, RowLengthsVectorType > matrixSetter;\n" )
    file.write( "   matrixSetter.template getRowLengths< Mesh::Dimensions >( mesh,\n" )
    file.write( "                                                            differentialOperator,\n" )
    file.write( "                                                            boundaryCondition,\n" )
    file.write( "                                                            rowLengths );\n" )
    file.write( "   matrix.setDimensions( dofs, dofs );\n" )
    file.write( "   if( ! matrix.setRowLengths( rowLengths ) )\n" )
    file.write( "      return false;\n" )
    file.write( "   return true;\n" )
    file.write( "}\n" )
    file.write( "\n" )
    file.write( "\n" )
    file.write( "\n" )
    file.write( "\n" )
    file.write( "\n" )
    file.write( "\n" )
    file.write( "\n" )
    file.close()
         
          

                   


            
print( "TNL Quickstart -- solver generator")
print( "----------------------------------")
projectName = input( "Project name: (whitespace characters are allowed)" )
problemName = input( "Problem name: (whitespace characters are NOT allowed)" )
generateMakefile( problemName )
generateMain( projectName, problemName )
generateProblem( projectName, problemName )